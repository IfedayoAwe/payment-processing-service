// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transactions.sql

package gen

import (
	"context"
	"database/sql"
	"time"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    id, idempotency_key, trace_id, from_wallet_id, to_wallet_id, type, amount, currency, status, exchange_rate
)
VALUES (gen_random_uuid()::text, $1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, idempotency_key, trace_id, from_wallet_id, to_wallet_id, type, amount, currency, status, provider_name, provider_reference, exchange_rate, failure_reason, created_at, updated_at
`

type CreateTransactionParams struct {
	IdempotencyKey string         `db:"idempotency_key" json:"idempotency_key"`
	TraceID        sql.NullString `db:"trace_id" json:"trace_id"`
	FromWalletID   sql.NullString `db:"from_wallet_id" json:"from_wallet_id"`
	ToWalletID     sql.NullString `db:"to_wallet_id" json:"to_wallet_id"`
	Type           string         `db:"type" json:"type"`
	Amount         int64          `db:"amount" json:"amount"`
	Currency       string         `db:"currency" json:"currency"`
	Status         string         `db:"status" json:"status"`
	ExchangeRate   sql.NullString `db:"exchange_rate" json:"exchange_rate"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.IdempotencyKey,
		arg.TraceID,
		arg.FromWalletID,
		arg.ToWalletID,
		arg.Type,
		arg.Amount,
		arg.Currency,
		arg.Status,
		arg.ExchangeRate,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.IdempotencyKey,
		&i.TraceID,
		&i.FromWalletID,
		&i.ToWalletID,
		&i.Type,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.ProviderName,
		&i.ProviderReference,
		&i.ExchangeRate,
		&i.FailureReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, idempotency_key, trace_id, from_wallet_id, to_wallet_id, type, amount, currency,
       status, provider_name, provider_reference, exchange_rate, failure_reason,
       created_at, updated_at
FROM transactions
WHERE id = $1
`

func (q *Queries) GetTransactionByID(ctx context.Context, id string) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.IdempotencyKey,
		&i.TraceID,
		&i.FromWalletID,
		&i.ToWalletID,
		&i.Type,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.ProviderName,
		&i.ProviderReference,
		&i.ExchangeRate,
		&i.FailureReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByIdempotencyKey = `-- name: GetTransactionByIdempotencyKey :one
SELECT id, idempotency_key, trace_id, from_wallet_id, to_wallet_id, type, amount, currency,
       status, provider_name, provider_reference, exchange_rate, failure_reason,
       created_at, updated_at
FROM transactions
WHERE idempotency_key = $1
`

func (q *Queries) GetTransactionByIdempotencyKey(ctx context.Context, idempotencyKey string) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByIdempotencyKey, idempotencyKey)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.IdempotencyKey,
		&i.TraceID,
		&i.FromWalletID,
		&i.ToWalletID,
		&i.Type,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.ProviderName,
		&i.ProviderReference,
		&i.ExchangeRate,
		&i.FailureReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listTransactionsByUser = `-- name: ListTransactionsByUser :many
SELECT t.id, t.idempotency_key, t.trace_id, t.from_wallet_id, t.to_wallet_id, t.type, t.amount, t.currency,
       t.status, t.provider_name, t.provider_reference, t.exchange_rate, t.failure_reason,
       t.created_at, t.updated_at
FROM transactions t
WHERE t.from_wallet_id IN (
    SELECT id FROM wallets WHERE user_id = $1
)
AND (
    $2::timestamp = '1970-01-01 00:00:00+00'::timestamp OR 
    (t.created_at < $2::timestamp OR (t.created_at = $2::timestamp AND t.id < $3))
)
ORDER BY t.created_at DESC, t.id DESC
LIMIT $4
`

type ListTransactionsByUserParams struct {
	UserID  string    `db:"user_id" json:"user_id"`
	Column2 time.Time `db:"column_2" json:"column_2"`
	ID      string    `db:"id" json:"id"`
	Limit   int32     `db:"limit" json:"limit"`
}

func (q *Queries) ListTransactionsByUser(ctx context.Context, arg ListTransactionsByUserParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsByUser,
		arg.UserID,
		arg.Column2,
		arg.ID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.IdempotencyKey,
			&i.TraceID,
			&i.FromWalletID,
			&i.ToWalletID,
			&i.Type,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.ProviderName,
			&i.ProviderReference,
			&i.ExchangeRate,
			&i.FailureReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionFailure = `-- name: UpdateTransactionFailure :exec
UPDATE transactions
SET status = $1, failure_reason = $2, updated_at = NOW()
WHERE id = $3
`

type UpdateTransactionFailureParams struct {
	Status        string         `db:"status" json:"status"`
	FailureReason sql.NullString `db:"failure_reason" json:"failure_reason"`
	ID            string         `db:"id" json:"id"`
}

func (q *Queries) UpdateTransactionFailure(ctx context.Context, arg UpdateTransactionFailureParams) error {
	_, err := q.db.ExecContext(ctx, updateTransactionFailure, arg.Status, arg.FailureReason, arg.ID)
	return err
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :exec
UPDATE transactions
SET status = $1, updated_at = NOW()
WHERE id = $2
`

type UpdateTransactionStatusParams struct {
	Status string `db:"status" json:"status"`
	ID     string `db:"id" json:"id"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTransactionStatus, arg.Status, arg.ID)
	return err
}

const updateTransactionWithProvider = `-- name: UpdateTransactionWithProvider :exec
UPDATE transactions
SET provider_name = $1, provider_reference = $2, status = $3, updated_at = NOW()
WHERE id = $4
`

type UpdateTransactionWithProviderParams struct {
	ProviderName      sql.NullString `db:"provider_name" json:"provider_name"`
	ProviderReference sql.NullString `db:"provider_reference" json:"provider_reference"`
	Status            string         `db:"status" json:"status"`
	ID                string         `db:"id" json:"id"`
}

func (q *Queries) UpdateTransactionWithProvider(ctx context.Context, arg UpdateTransactionWithProviderParams) error {
	_, err := q.db.ExecContext(ctx, updateTransactionWithProvider,
		arg.ProviderName,
		arg.ProviderReference,
		arg.Status,
		arg.ID,
	)
	return err
}
