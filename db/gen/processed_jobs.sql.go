// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: processed_jobs.sql

package gen

import (
	"context"
	"time"
)

const cleanupExpiredJobs = `-- name: CleanupExpiredJobs :exec
DELETE FROM processed_jobs WHERE expires_at < NOW()
`

func (q *Queries) CleanupExpiredJobs(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupExpiredJobs)
	return err
}

const isJobProcessed = `-- name: IsJobProcessed :one
SELECT EXISTS(SELECT 1 FROM processed_jobs WHERE job_id = $1) as processed
`

func (q *Queries) IsJobProcessed(ctx context.Context, jobID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, isJobProcessed, jobID)
	var processed bool
	err := row.Scan(&processed)
	return processed, err
}

const markJobProcessed = `-- name: MarkJobProcessed :one
INSERT INTO processed_jobs (job_id, expires_at)
VALUES ($1, $2)
ON CONFLICT (job_id) DO NOTHING
RETURNING job_id, processed_at, expires_at
`

type MarkJobProcessedParams struct {
	JobID     string    `db:"job_id" json:"job_id"`
	ExpiresAt time.Time `db:"expires_at" json:"expires_at"`
}

func (q *Queries) MarkJobProcessed(ctx context.Context, arg MarkJobProcessedParams) (ProcessedJob, error) {
	row := q.db.QueryRowContext(ctx, markJobProcessed, arg.JobID, arg.ExpiresAt)
	var i ProcessedJob
	err := row.Scan(&i.JobID, &i.ProcessedAt, &i.ExpiresAt)
	return i, err
}
